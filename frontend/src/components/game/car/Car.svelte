<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.1 .\car.glb -T --draco /draco/
-->

<script lang="ts">
  import { T } from "@threlte/core";
  import { MeshLineMaterial, useDraco, useGltf } from "@threlte/extras";
  import {
    AddEquation,
    BufferGeometry,
    CustomBlending,
    OneFactor,
    Shape,
  } from "three";
  import { createCustomExtrudedGeometry } from "./Nitro";

  let {
    position,
    rotation,
    color,
    fallback = () => {},
    error = () => {},
    children = () => {},
    ref = $bindable(),
    ...props
  } = $props();

  const gltf = useGltf("/car-transformed.glb", { dracoLoader: useDraco() });

  let geometry: BufferGeometry | undefined = $state<BufferGeometry>();

  const shape = new Shape();
  shape.moveTo(0, 0.2);
  shape.lineTo(-0.5, -0.35);
  shape.lineTo(0.5, -0.35);
  shape.lineTo(0, 0.2);

  geometry = createCustomExtrudedGeometry(shape, 2, 0);
</script>

<T.Group {position} {rotation} bind:ref dispose={false} {...props}>
  {#await gltf}
    {@render fallback?.()}
  {:then gltf}
    <T.Mesh {geometry} position={[0, 1.35, -1]} rotation={[0, Math.PI, 0]}>
      <T.MeshBasicMaterial
        color={"red"}
        transparent={true}
        opacity={0.5}
        blending={CustomBlending}
        blendDst={OneFactor}
        blendEquation={AddEquation}
      />
    </T.Mesh>

    <T.Mesh
      geometry={gltf.nodes.car.geometry}
      material={gltf.materials["Material.002"]}
      position={[0, 0.84, 0]}
      rotation={[Math.PI / 2, 0, 0]}
    >
      <MeshLineMaterial color={color} linewidth={0.1} />
    </T.Mesh>
    <T.Mesh
      geometry={gltf.nodes.glass.geometry}
      material={gltf.materials["FrontColor.001"]}
      position={[0, 0.84, 0]}
      rotation={[Math.PI / 2, 0, 0]}
    >
      <MeshLineMaterial color="white" linewidth={0.1} />
    </T.Mesh>
    <T.Mesh
      geometry={gltf.nodes.side_light.geometry}
      material={gltf.materials["FrontColor.001"]}
      position={[0, 0.84, 0]}
      rotation={[Math.PI / 2, 0, 0]}
    >
      <MeshLineMaterial color="cyan" linewidth={0.1} />
    </T.Mesh>
    <T.Mesh
      geometry={gltf.nodes.front_light.geometry}
      material={gltf.materials["FrontColor.001"]}
      position={[0, 0.84, 0]}
      rotation={[Math.PI / 2, 0, 0]}
    >
      <MeshLineMaterial color="purple" linewidth={0.1} />
    </T.Mesh>
    <T.Mesh
      geometry={gltf.nodes.stop_light_1.geometry}
      material={gltf.materials["FrontColor.001"]}
      position={[0, 0.84, 0]}
      rotation={[Math.PI / 2, 0, 0]}
    >
      <MeshLineMaterial color="orange" linewidth={0.1} />
    </T.Mesh>
    <T.Mesh
      geometry={gltf.nodes.nitro.geometry}
      material={gltf.materials["FrontColor.001"]}
      position={[0, 0.84, 0]}
      rotation={[Math.PI / 2, 0, 0]}
    >
      <MeshLineMaterial color="#6355df" linewidth={0.1} />
    </T.Mesh>
    <T.Mesh
      geometry={gltf.nodes.stop_light_2.geometry}
      material={gltf.materials["FrontColor.001"]}
      position={[0, 0.84, 0]}
      rotation={[Math.PI / 2, 0, 0]}
    >
      <MeshLineMaterial color="orange" linewidth={0.1} />
    </T.Mesh>
    <T.Mesh
      geometry={gltf.nodes.stop_light_3.geometry}
      material={gltf.materials["FrontColor.001"]}
      position={[0, 0.84, 0]}
      rotation={[Math.PI / 2, 0, 0]}
    >
      <MeshLineMaterial color="red" linewidth={0.1} />
    </T.Mesh>
    <T.Mesh
      geometry={gltf.nodes.plate.geometry}
      material={gltf.materials["FrontColor.001"]}
      position={[0, 0.84, 0]}
      rotation={[Math.PI / 2, 0, 0]}
    >
      <MeshLineMaterial color="#6355df" linewidth={0.1} />
    </T.Mesh>
  {:catch err}
    {@render error?.({ error: err })}
  {/await}

  {@render children?.({ ref })}
</T.Group>
