<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.1 .\man.glb -T --draco /draco/
-->

<script lang="ts">
  import { gameState, keys } from "#stores/gameStore";
  import { isOnStage } from "#stores/parkStores";
  import { isInShop } from "#stores/shopStore";
  import { type RigidBody as RapierRigidBody } from "@dimforge/rapier3d-compat";
  import { T, useTask, useThrelte } from "@threlte/core";
  import { useDraco, useGltf, useGltfAnimations } from "@threlte/extras";
  import { Collider, RigidBody } from "@threlte/rapier";
  import { Group, Vector3 } from "three";
  import { Controls } from "../controls/th3";

  import type { AnimationKey, PlayerLocationData } from "#types/player";

  import { type WebSocketMessage } from "#types/ws";
  import { wsService } from "#websockets/websockets";

  import { useVip } from "#hooks/useVip";
  const { vipStore, loadVipData, buyMembership } = useVip();

  const { status, messages } = wsService;

  let {
    playerInfo,
    cameraRef,
    fallback = () => {},
    error = () => {},
    children = () => {},
    ref = $bindable(),
    ...props
  } = $props();

  ref = new Group();
  const gltf = useGltf("/man-transformed.glb", { dracoLoader: useDraco() });

  export const { actions, mixer } = useGltfAnimations(gltf, ref);

  const v3 = new Vector3();
  let mainGroupRef: Group | undefined = $state<Group>();
  let cameraAxis = $state<Group | undefined>();
  let cameraTrack = $state<Group | undefined>();
  let rigidBody: RapierRigidBody | undefined = $state<RapierRigidBody>();
  let objectRef: Group | undefined = $state<Group>();
  // let cameraRef: PerspectiveCamera | undefined = $state<PerspectiveCamera>();
  let controls: Controls | undefined;
  let inInterior = $state(false);
  let groundContacts = $state(1);
  let isOnGround = $state(true);
  let _position: [number, number, number] = $state([
    playerInfo.position.x,
    playerInfo.position.y,
    playerInfo.position.z,
  ]); // Bajar al nivel del suelo
  let _rotation: [number, number, number] = $state([0, 0, 0]);

  const { camera } = useThrelte();

  $effect(() => {
    // Esperar a que todos los elementos estén disponibles
    if (
      objectRef &&
      cameraRef &&
      mainGroupRef &&
      cameraAxis &&
      cameraTrack &&
      rigidBody &&
      objectRef
    ) {
      controls = new Controls({
        camera: $camera,
        player: mainGroupRef,
        cameraAxis: cameraAxis,
        cameraTrack: cameraTrack,
        //@ts-ignore
        body: rigidBody,
        objectRef: objectRef,
      });

      // Registrar los controles DESPUÉS de crearlos usando gameState.update para reactividad
      gameState.update((state) => ({
        ...state,
        player: {
          ...state.player,
          mainGroup: mainGroupRef,
        },
        controls: {
          ...state.controls,
          player: controls,
        },
      }));

      // console.log("🎮 Player controls registered successfully");

      cameraAxis.position.set(-25, 80, 0);
      cameraTrack.position.set(0, 150, -300);

      // Los event listeners de mouse ahora se manejan centralmente en gameController
    }
  });

  $effect(() => {
    const unsubscribe = isInShop.subscribe((value) => {
      inInterior = value;
      if (inInterior) {
        cameraAxis?.position.set(-25, 80, 0);
        cameraTrack?.position.set(0, 75, -100);
      } else {
        cameraAxis?.position.set(-25, 80, 0);
        cameraTrack?.position.set(0, 150, -300);
      }
    });

    return unsubscribe;
  });

  $effect(() => {
    const unsubscribe = isOnStage.subscribe((value) => {
      if (value) {
        cameraAxis?.position.set(-25, 80, 0);
        cameraTrack?.position.set(0, 50, -75);
      } else {
        cameraAxis?.position.set(-25, 80, 0);
        cameraTrack?.position.set(0, 150, -300);
      }
    });
    return unsubscribe;
  });

  let currentActionKey: AnimationKey = "Idle";
  let lastSentAnimation: AnimationKey = "Idle";

  function transitionTo(actionKey: AnimationKey, duration = 0.3) {
    if (!$actions) return;

    const currentAction = $actions[currentActionKey];
    const nextAction = $actions[actionKey];

    if (!nextAction || currentAction === nextAction) return;

    // Enable the next action
    nextAction.enabled = true;

    if (currentAction) {
      // Smooth transition between animations
      currentAction.crossFadeTo(nextAction, duration, true);
    }

    // Play the next action
    nextAction.play();
    currentActionKey = actionKey;
  }

  // Inicializar animación idle cuando las acciones estén disponibles
  $effect(() => {
    if ($actions && Object.keys($actions).length > 0) {
      if ($actions.Idle && currentActionKey === "Idle") {
        // Detener todas las otras animaciones primero
        Object.values($actions).forEach((action: any) => {
          if (action && action !== $actions.Idle) {
            action.stop();
          }
        });
        $actions.Idle.play();
      }
    }
  });

  useTask(() => {
    if (!rigidBody || !objectRef || !cameraRef || !controls || !mainGroupRef)
      return;

    // Verificar si hay una posición de salida del vehículo
    if ($gameState.player.exitPosition && $gameState.controlMode === "player") {
      const exitPos = $gameState.player.exitPosition;

      // Limpiar inmediatamente para evitar múltiples intentos
      $gameState.player.exitPosition = undefined;

      rigidBody.setTranslation(exitPos, true);
      // También resetear la velocidad para evitar movimiento residual
      rigidBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
      rigidBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
    }

    // Solo ejecutar controles del jugador cuando esté en modo player
    if ($gameState.controlMode !== "player") {
      return;
    }

    const cameraDirection = cameraRef.getWorldDirection(v3);
    const thetaCamera = Math.atan2(cameraDirection.x, cameraDirection.z);

    const pos = rigidBody.translation();
    _position = [pos.x, pos.y, pos.z];

    // Debug: mostrar posición del jugador cada 60 frames (1 segundo)
    if (
      Math.floor(Date.now() / 1000) % 2 === 0 &&
      Math.floor(Date.now() / 16) % 60 === 0
    ) {
    }

    let currentVelocity = 0;

    // Movimiento hacia adelante (W)
    if (
      $keys.w.isPressed &&
      $keys.shift.isPressed &&
      $gameState.player.canMove
    ) {
      currentVelocity = 8;
    } else if ($keys.w.isPressed && $gameState.player.canMove) {
      currentVelocity = 4;
    }

    if (currentVelocity > 0) {
      const x = Math.sin(thetaCamera) * currentVelocity;
      const z = Math.cos(thetaCamera) * currentVelocity;
      const currentVel = rigidBody.linvel();
      rigidBody.setLinvel({ x, y: currentVel.y, z }, true);

      // Transición suave de animaciones
      if (currentVelocity >= 6) {
        transitionTo("Running");
      } else {
        transitionTo("Walking");
      }
    } else {
      transitionTo("Idle");
    }

    controls.update(0, 0);

    // Solo enviar animación si cambió
    const shouldSendAnimation = lastSentAnimation !== currentActionKey;
    if (shouldSendAnimation) {
      lastSentAnimation = currentActionKey;
    }

    // Preparar datos para enviar
    const locationData = {
      position: {
        x: pos.x,
        y: pos.y,
        z: pos.z,
      },
      rotation: {
        x: objectRef.rotation.x,
        y: objectRef.rotation.y,
        z: objectRef.rotation.z,
      },
    };

    // Solo incluir animación si cambió para reducir ancho de banda
    if (shouldSendAnimation) {
      locationData.animation = {
        current: currentActionKey,
        changed: true,
      };
    }

    wsService.send({
      type: "playerLocation",
      ...locationData,
    });
  });

  messages.subscribe((message: WebSocketMessage | null) => {
    if (message?.type) {
      switch (message.type) {
        case "player:spawn": {
          const { position } = message;
          if (position && rigidBody) {
            rigidBody.setTranslation(position, true);
            rigidBody.setRotation({ x: 0, y: 0, z: 0, w: 1 }, true);
            rigidBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
            rigidBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
            rigidBody.setEnabled(true);
          }
          break;
        }
      }
    }
  });

  vipStore.subscribe((data) => {
    if (data.isVip) {
      wsService.send({ type: "vip", isVip: data.isVip });
    }
  });
</script>

{#if $gameState.player.isVisible && $status === "open"}
  <T is={ref} dispose={false} {...props}>
    {#await gltf}
      {@render fallback?.()}
    {:then gltf}
      <T.Group
        name="Scene"
        position={_position}
        rotation={_rotation}
        bind:ref={mainGroupRef}
      >
        <RigidBody
          bind:rigidBody
          enabledRotations={[false, false, false]}
          lockRotations
          userData={{ name: "player", id: playerInfo.id }}
        >
          <Collider shape="capsule" args={[0.5, 0.4]}>
            <T.Group
              name="Armature"
              position={[0, -0.9, 0]}
              scale={0.02}
              bind:ref={objectRef}
            >
              <T.Group name="cameraAxis" bind:ref={cameraAxis}>
                <!-- CameraTrack debe ser hijo de CameraAxis -->
                <T.Group name="cameraTrack" bind:ref={cameraTrack}>
                  <T.Mesh>
                    <!-- <T.BoxGeometry args={[0.1, 0.1, 0.1]} /> -->
                    <!-- <T.MeshStandardMaterial color="blue" /> -->
                  </T.Mesh>
                </T.Group>

                <T.Mesh>
                  <!-- <T.BoxGeometry args={[0.1, 0.1, 0.1]} /> -->
                  <!-- <T.MeshStandardMaterial color="red" /> -->
                </T.Mesh>
              </T.Group>

              <T is={gltf.nodes.mixamorigHips} />
              {#if $vipStore.isVip}
                <T.SkinnedMesh
                  name="corona001"
                  geometry={gltf.nodes.corona001.geometry}
                  material={gltf.materials["Material.061"]}
                  skeleton={gltf.nodes.corona001.skeleton}
                />
              {/if}
              <T.Group name="cuerpo_base001">
                <T.SkinnedMesh
                  name="tripo_mesh_ca4578fd004"
                  geometry={gltf.nodes.tripo_mesh_ca4578fd004.geometry}
                  material={gltf.materials.tripo_mat_ca4578fd}
                  skeleton={gltf.nodes.tripo_mesh_ca4578fd004.skeleton}
                />
                <T.SkinnedMesh
                  name="tripo_mesh_ca4578fd004_1"
                  geometry={gltf.nodes.tripo_mesh_ca4578fd004_1.geometry}
                  material={gltf.materials["Material.063"]}
                  skeleton={gltf.nodes.tripo_mesh_ca4578fd004_1.skeleton}
                />
              </T.Group>
              {#if $vipStore.isVip}
                <T.SkinnedMesh
                  name="guantes_vip001"
                  geometry={gltf.nodes.guantes_vip001.geometry}
                  material={gltf.materials["Material.063"]}
                  skeleton={gltf.nodes.guantes_vip001.skeleton}
                />
                <T.SkinnedMesh
                  name="lentes_vip001"
                  geometry={gltf.nodes.lentes_vip001.geometry}
                  material={gltf.materials["Material.061"]}
                  skeleton={gltf.nodes.lentes_vip001.skeleton}
                />
              {/if}
              {#if !$vipStore.isVip}
                <T.SkinnedMesh
                  name="suerter_base001"
                  geometry={gltf.nodes.suerter_base001.geometry}
                  material={gltf.materials["material vip black.005"]}
                  skeleton={gltf.nodes.suerter_base001.skeleton}
                />
              {/if}

              {#if $vipStore.isVip}
                <T.Group name="suerter_vip001">
                  <T.SkinnedMesh
                    name="white_circle_360x360004"
                    geometry={gltf.nodes.white_circle_360x360004.geometry}
                    material={gltf.materials["Material.063"]}
                    skeleton={gltf.nodes.white_circle_360x360004.skeleton}
                  />
                  <T.SkinnedMesh
                    name="white_circle_360x360004_1"
                    geometry={gltf.nodes.white_circle_360x360004_1.geometry}
                    material={gltf.materials["Material.061"]}
                    skeleton={gltf.nodes.white_circle_360x360004_1.skeleton}
                  />
                </T.Group>
              {/if}

              {#if !$vipStore.isVip}
                <T.SkinnedMesh
                  name="zapatos_base001"
                  geometry={gltf.nodes.zapatos_base001.geometry}
                  material={gltf.materials["material vip black.005"]}
                  skeleton={gltf.nodes.zapatos_base001.skeleton}
                />
              {/if}

              {#if $vipStore.isVip}
                <T.SkinnedMesh
                  name="zapatos_vip001"
                  geometry={gltf.nodes.zapatos_vip001.geometry}
                  material={gltf.materials["Material.061"]}
                  skeleton={gltf.nodes.zapatos_vip001.skeleton}
                />
              {/if}
            </T.Group>
          </Collider>
        </RigidBody>
      </T.Group>
    {:catch err}
      {@render error?.({ error: err })}
    {/await}

    {@render children?.({ ref })}
  </T>
{/if}
