<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.1 .\man.glb -T --draco /draco/
-->

<script lang="ts">
  import { type RigidBody as RapierRigidBody } from "@dimforge/rapier3d-compat";
  import { T, useTask } from "@threlte/core";
  import { useDraco, useGltf, useGltfAnimations, HTML } from "@threlte/extras";
  import { Collider, RigidBody } from "@threlte/rapier";
  import { Group } from "three";
  import type { AnimationKey, NetworkPlayer } from "../../../../types/player";

  let {
    playerInfo,
    ref = $bindable(),
    ...props
  }: {
    playerInfo: NetworkPlayer;
    ref?: Group;
  } = $props();

  ref = new Group();

  let isVip = $state(false);

  // Generate unique names for this player instance to avoid conflicts
  const playerId = playerInfo.id || Math.random().toString(36).substring(2, 11);
  const uniquePrefix = `player_${playerId}`;

  // Use a unique GLTF file path for each player to avoid conflicts
  const gltfPath = `/man-transformed.glb?player=${playerId}`;
  const originalGltf = useGltf(gltfPath, {
    dracoLoader: useDraco(),
  });

  let mainGroupRef: Group | undefined = $state<Group>();
  let rigidBody: RapierRigidBody | undefined = $state<RapierRigidBody>();
  let objectRef: Group | undefined = $state<Group>();
  let position: [number, number, number] = $state([265, 20, 100]);
  let rotation: [number, number, number] = $state([0, 0, 0]);

  // Animation setup and material cloning
  let clonedMaterials: any = $state({});

  // Clone materials to avoid sharing between instances
  $effect(() => {
    if ($originalGltf && $originalGltf.materials) {
      const newClonedMaterials: any = {};
      Object.keys($originalGltf.materials).forEach((key) => {
        const originalMaterial = $originalGltf.materials[key];
        if (originalMaterial && originalMaterial.clone) {
          newClonedMaterials[key] = originalMaterial.clone();
        }
      });
      clonedMaterials = newClonedMaterials;
    }
  });

  const { actions } = useGltfAnimations(originalGltf, ref);

  let currentActionKey: AnimationKey = "Idle";
  let lastAnimationTimestamp = 0;

  function transitionTo(actionKey: AnimationKey, duration = 0.3) {
    if (!$actions) return;

    const currentAction = $actions[currentActionKey];
    const nextAction = $actions[actionKey];

    if (!nextAction || currentAction === nextAction) return;

    // Enable the next action
    nextAction.enabled = true;

    if (currentAction) {
      // Smooth transition between animations
      currentAction.crossFadeTo(nextAction, duration, true);
    }

    // Play the next action
    nextAction.play();
    currentActionKey = actionKey;
  }

  // Inicializar con animación idle cuando las acciones estén disponibles
  $effect(() => {
    if ($actions && Object.keys($actions).length > 0) {
      if ($actions.Idle && currentActionKey === "Idle") {
        // Asegurar que solo Idle esté activo al inicio
        Object.values($actions).forEach((action: any) => {
          if (action && action !== $actions.Idle) {
            action.stop();
          }
        });
        $actions.Idle.play();
      }
    }
  });

  //   // Cleanup cloned materials when component unmounts
  //   $effect(() => {
  //     return () => {
  //       Object.values(clonedMaterials).forEach((material: any) => {
  //         if (material && material.dispose) {
  //           material.dispose();
  //         }
  //       });
  //     };
  //   });

  useTask(() => {
    if (!rigidBody || !mainGroupRef || !objectRef || !playerInfo) return;

    isVip = playerInfo.isVip;

    // Actualizar posición
    position = [
      playerInfo.position.x,
      playerInfo.position.y,
      playerInfo.position.z,
    ];

    rigidBody.setTranslation(
      {
        x: playerInfo.position.x,
        y: playerInfo.position.y,
        z: playerInfo.position.z,
      },
      true
    );

    // Actualizar rotación
    objectRef.rotation.set(
      playerInfo.rotation.x,
      playerInfo.rotation.y,
      playerInfo.rotation.z
    );

    // Actualizar animación si cambió y es más reciente
    if (
      playerInfo.animation &&
      playerInfo.animation.changed &&
      playerInfo.animation.timestamp &&
      playerInfo.animation.timestamp > lastAnimationTimestamp
    ) {
      const newAnimation = playerInfo.animation.current as AnimationKey;
      if (newAnimation !== currentActionKey) {
        transitionTo(newAnimation);
        lastAnimationTimestamp = playerInfo.animation.timestamp;
      }
    }
  });
</script>

<T is={ref} dispose={false} {...props}>
  {#await originalGltf}
    <T.Mesh>
      <T.BoxGeometry args={[1, 1, 1]} />
      <T.MeshStandardMaterial color="gray" />
    </T.Mesh>
  {:then gltf}
    <T.Group
      name="{uniquePrefix}_Scene"
      {position}
      {rotation}
      bind:ref={mainGroupRef}
    >
      <RigidBody
        bind:rigidBody
        enabledRotations={[false, false, false]}
        lockRotations
        userData={{ name: uniquePrefix }}
      >
        <Collider shape="capsule" args={[0.5, 0.4]}>
          <T.Group
            name="{uniquePrefix}_Armature"
            position={[0, -0.9, 0]}
            scale={0.02}
            bind:ref={objectRef}
          >
            {#if isVip}
              <T.Group scale={70}>
                <HTML
                  transform
                  position={[0.2, 2, 0]}
                  rotation={[0, Math.PI * 2, 0]}
                >
                  <div class="absolute top-0 right-0 text-white text-xs">
                    <h1 class="font-bold text-yellow-500">VIP</h1>
                  </div>
                </HTML>

                <T.PointLight
                  castShadow
                  intensity={20}
                  position={[0, 2, 0]}
                  color="gold"
                />
              </T.Group>
            {/if}

            <!-- Animation reference group -->
            <!-- <T.Group bind:ref={animationRef}>
              {#if gltf.nodes?.mixamorigHips} -->
            <T is={gltf.nodes.mixamorigHips} />
            <!-- {/if}
            </T.Group> -->

            <!-- Render all the meshes directly with cloned materials -->
            {#if Object.keys(clonedMaterials).length > 0}
              {#if isVip}
                <T.SkinnedMesh
                  name="{uniquePrefix}_corona001"
                  geometry={gltf.nodes.corona001.geometry}
                  material={clonedMaterials["Material.061"]}
                  skeleton={gltf.nodes.corona001.skeleton}
                />
              {/if}
            {/if}

            {#if Object.keys(clonedMaterials).length > 0}
              <T.Group name="{uniquePrefix}_cuerpo_base001">
                <T.SkinnedMesh
                  name="{uniquePrefix}_tripo_mesh_ca4578fd004"
                  geometry={gltf.nodes.tripo_mesh_ca4578fd004.geometry}
                  material={clonedMaterials.tripo_mat_ca4578fd}
                  skeleton={gltf.nodes.tripo_mesh_ca4578fd004.skeleton}
                />
                <T.SkinnedMesh
                  name="{uniquePrefix}_tripo_mesh_ca4578fd004_1"
                  geometry={gltf.nodes.tripo_mesh_ca4578fd004_1.geometry}
                  material={clonedMaterials["Material.063"]}
                  skeleton={gltf.nodes.tripo_mesh_ca4578fd004_1.skeleton}
                />
              </T.Group>
            {/if}
            {#if Object.keys(clonedMaterials).length > 0}
              {#if isVip}
                <T.SkinnedMesh
                  name="{uniquePrefix}_guantes_vip001"
                  geometry={gltf.nodes.guantes_vip001.geometry}
                  material={clonedMaterials["Material.063"]}
                  skeleton={gltf.nodes.guantes_vip001.skeleton}
                />
                <T.SkinnedMesh
                  name="{uniquePrefix}_lentes_vip001"
                  geometry={gltf.nodes.lentes_vip001.geometry}
                  material={clonedMaterials["Material.061"]}
                  skeleton={gltf.nodes.lentes_vip001.skeleton}
                />
              {/if}

              {#if !isVip}
                <T.SkinnedMesh
                  name="{uniquePrefix}_suerter_base001"
                  geometry={gltf.nodes.suerter_base001.geometry}
                  material={clonedMaterials["material vip black.005"]}
                  skeleton={gltf.nodes.suerter_base001.skeleton}
                />
              {/if}
            {/if}
            {#if Object.keys(clonedMaterials).length > 0}
              {#if isVip}
                <T.Group name="{uniquePrefix}_suerter_vip001">
                  <T.SkinnedMesh
                    name="{uniquePrefix}_white_circle_360x360004"
                    geometry={gltf.nodes.white_circle_360x360004.geometry}
                    material={clonedMaterials["Material.063"]}
                    skeleton={gltf.nodes.white_circle_360x360004.skeleton}
                  />
                  <T.SkinnedMesh
                    name="{uniquePrefix}_white_circle_360x360004_1"
                    geometry={gltf.nodes.white_circle_360x360004_1.geometry}
                    material={clonedMaterials["Material.061"]}
                    skeleton={gltf.nodes.white_circle_360x360004_1.skeleton}
                  />
                </T.Group>
              {/if}
            {/if}
            {#if Object.keys(clonedMaterials).length > 0}
              {#if !isVip}
                <T.SkinnedMesh
                  name="{uniquePrefix}_zapatos_base001"
                  geometry={gltf.nodes.zapatos_base001.geometry}
                  material={clonedMaterials["material vip black.005"]}
                  skeleton={gltf.nodes.zapatos_base001.skeleton}
                />
              {/if}

              {#if isVip}
                <T.SkinnedMesh
                  name="{uniquePrefix}_zapatos_vip001"
                  geometry={gltf.nodes.zapatos_vip001.geometry}
                  material={clonedMaterials["Material.061"]}
                  skeleton={gltf.nodes.zapatos_vip001.skeleton}
                />
              {/if}
            {/if}
          </T.Group>
        </Collider>
      </RigidBody>
    </T.Group>
  {:catch err}
    <T.Mesh>
      <T.BoxGeometry args={[1, 1, 1]} />
      <T.MeshStandardMaterial color="red" />
    </T.Mesh>
  {/await}
</T>
